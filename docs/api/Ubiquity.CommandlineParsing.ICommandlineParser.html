<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
      <title>Interface ICommandLineParser | Command line parsing </title>
      <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <meta name="title" content="Interface ICommandLineParser | Command line parsing ">
      
      <meta name="description" content="Interface for parsing command line arguments.">
      <link rel="icon" href="../favicon.ico">
      <link rel="stylesheet" href="../public/docfx.min.css">
      <link rel="stylesheet" href="../public/main.css">
      <meta name="docfx:navrel" content="../toc.html">
      <meta name="docfx:tocrel" content="toc.html">
      
      
      
      
      <meta name="docfx:docurl" content="https://github.com/UbiquityDotNET/CommandLineParsing/new/master/apiSpec/new?filename=Ubiquity_CommandLineParsing_ICommandLineParser.md&amp;value=---%0Auid%3A%20Ubiquity.CommandLineParsing.ICommandLineParser%0Asummary%3A%20&#39;*You%20can%20override%20summary%20for%20the%20API%20here%20using%20*MARKDOWN*%20syntax&#39;%0A---%0A%0A*Please%20type%20below%20more%20information%20about%20this%20API%3A*%0A%0A">
      <meta name="loc:inThisArticle" content="In this article">
      <meta name="loc:searchResultsCount" content="{count} results for &quot;{query}&quot;">
      <meta name="loc:searchNoResults" content="No results for &quot;{query}&quot;">
      <meta name="loc:tocFilter" content="Filter by title">
      <meta name="loc:nextArticle" content="Next">
      <meta name="loc:prevArticle" content="Previous">
      <meta name="loc:themeLight" content="Light">
      <meta name="loc:themeDark" content="Dark">
      <meta name="loc:themeAuto" content="Auto">
      <meta name="loc:changeTheme" content="Change theme">
      <meta name="loc:copy" content="Copy">
      <meta name="loc:downloadPdf" content="Download PDF">

      <script type="module" src="./../public/docfx.min.js"></script>

      <script>
        const theme = localStorage.getItem('theme') || 'auto'
        document.documentElement.setAttribute('data-bs-theme', theme === 'auto' ? (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light') : theme)
      </script>

  </head>

  <body class="tex2jax_ignore" data-layout="" data-yaml-mime="ManagedReference">
    <header class="bg-body border-bottom">
      <nav id="autocollapse" class="navbar navbar-expand-md" role="navigation">
        <div class="container-xxl flex-nowrap">
          <a class="navbar-brand" href="../index.html">
            <img id="logo" class="svg" src="../images/custom-logo.svg" alt="Command Line Parsing">
            Command Line Parsing
          </a>
          <button class="btn btn-lg d-md-none border-0" type="button" data-bs-toggle="collapse" data-bs-target="#navpanel" aria-controls="navpanel" aria-expanded="false" aria-label="Toggle navigation">
            <i class="bi bi-three-dots"></i>
          </button>
          <div class="collapse navbar-collapse" id="navpanel">
            <div id="navbar">
            </div>
          </div>
        </div>
      </nav>
    </header>

    <main class="container-xxl">
      <div class="toc-offcanvas">
        <div class="offcanvas-md offcanvas-start" tabindex="-1" id="tocOffcanvas" aria-labelledby="tocOffcanvasLabel">
          <div class="offcanvas-header">
            <h5 class="offcanvas-title" id="tocOffcanvasLabel">Table of Contents</h5>
            <button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#tocOffcanvas" aria-label="Close"></button>
          </div>
          <div class="offcanvas-body">
            <nav class="toc" id="toc"></nav>
          </div>
        </div>
      </div>

      <div class="content">
        <div class="actionbar">
          <button class="btn btn-lg border-0 d-md-none" type="button" data-bs-toggle="offcanvas" data-bs-target="#tocOffcanvas" aria-controls="tocOffcanvas" aria-expanded="false" aria-label="Show table of contents">
            <i class="bi bi-list"></i>
          </button>

        </div>

        <article data-uid="Ubiquity.CommandLineParsing.ICommandLineParser">



  <h1 id="Ubiquity_CommandLineParsing_ICommandLineParser" data-uid="Ubiquity.CommandLineParsing.ICommandLineParser" class="text-break">
Interface ICommandLineParser  <a class="header-action link-secondary" title="View source" href="https://github.com/UbiquityDotNET/CommandLineParsing/blob/master/src/Ubiquity.CommandlineParsing/ICommandLineParser.cs/#L43"><i class="bi bi-code-slash"></i></a>
  </h1>

  <div class="facts text-secondary">
    <dl><dt>Namespace</dt><dd><a class="xref" href="Ubiquity.html">Ubiquity</a>.<a class="xref" href="Ubiquity.CommandLineParsing.html">CommandLineParsing</a></dd></dl>
  <dl><dt>Assembly</dt><dd>Ubiquity.CommandLineParsing.dll</dd></dl>
  </div>

  <div class="markdown summary"><p>Interface for parsing command line arguments.</p>
</div>
  <div class="markdown conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">public interface ICommandLineParser</code></pre>
  </div>








  <dl class="typelist extensionMethods">
    <dt>Extension Methods</dt>
    <dd>
  <div>
      <a class="xref" href="Ubiquity.CommandlineParsing.CommandLineBinderExtensions.html#Ubiquity_CommandLineParsing_CommandLineBinderExtensions_BindArguments__1___0_System_Collections_Immutable_IImmutableList_Ubiquity_CommandLineParsing_ICommandLineArgument__">CommandLineBinderExtensions.BindArguments&lt;TResult&gt;(TResult, IImmutableList&lt;ICommandLineArgument&gt;)</a>
  </div>
  </dd></dl>



  <h2 id="Ubiquity_CommandLineParsing_ICommandLineParser_remarks">Remarks</h2>
  <div class="markdown level0 remarks"><p>This interface allows for different underlying parsing engines,
depending on the needs of an application. For example there is a
monad parser available that uses the Sprache parser combinator
library. However, if the app already has a full featured parser,
like ANTLR, it may not make sense to pull in the dependencies for
the Sprache parser and instead, just use the ANTLR version instead.</p>
<p>The parser accepts a superset of all valid command lines. That is,
it parses and accepts without error all syntactically and semantically valid
input AND some semantically invalid input. It is then up to the consuming
application or binder to perform the final semantic evaluation. This helps
keep the parser implementations generalized enough for re-use as-is while
supporting a wide variety of command line styles without enforcing any
one in particular.
</p>
<div class="NOTE"><h5>Important</h5><p>
It is important to note that the result of the parse is intentionally
**not** necessarily semantically valid for a given application. That is,
the parser does not implement all the subtle rules of a particular use
case. Instead it parses the fundamental syntax, and leaves the semantics
to the consumer of the results. For example, '-a --all' would parse as
two distinct options. It is up to the application or binder it uses to
decide if that is an error. (They may represent distinct options or the
'-a' may be a short form of '--all'. If they represent the same option, it
is up to the application to decide if the multiple occurrences are valid
or an error) This helps keep the parser implementation generally reusable
and simplifies most applications to focusing on the task of validating
the arguments instead of parsing them.
</p></div>
</div>


  <h2 class="section" id="methods">Methods
</h2>


  <a id="Ubiquity_CommandLineParsing_ICommandLineParser_Parse_" data-uid="Ubiquity.CommandLineParsing.ICommandLineParser.Parse*"></a>

  <h3 id="Ubiquity_CommandLineParsing_ICommandLineParser_Parse_System_Collections_Generic_IEnumerable_System_String__" data-uid="Ubiquity.CommandLineParsing.ICommandLineParser.Parse(System.Collections.Generic.IEnumerable{System.String})">
  Parse(IEnumerable&lt;string&gt;)
  <a class="header-action link-secondary" title="View source" href="https://github.com/UbiquityDotNET/CommandLineParsing/blob/master/src/Ubiquity.CommandlineParsing/ICommandLineParser.cs/#L64"><i class="bi bi-code-slash"></i></a>
  </h3>

  <div class="markdown level1 summary"><p>Parse arguments list from platform provided list of args.</p>
</div>
  <div class="markdown level1 conceptual"></div>

  <div class="codewrapper">
    <pre><code class="lang-csharp hljs">IImmutableList&lt;ICommandLineArgument&gt; Parse(IEnumerable&lt;string&gt; args)</code></pre>
  </div>

  <h4 class="section">Parameters</h4>
  <dl class="parameters">
    <dt><code>args</code> <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.collections.generic.ienumerable-1">IEnumerable</a>&lt;<a class="xref" href="https://learn.microsoft.com/dotnet/api/system.string">string</a>&gt;</dt>
    <dd><p>Args list provided to Main() or via <a class="xref" href="https://learn.microsoft.com/dotnet/api/system.environment.getcommandlineargs">GetCommandLineArgs()</a>.</p>
</dd>
  </dl>

  <h4 class="section">Returns</h4>
  <dl class="parameters">
    <dt><a class="xref" href="https://learn.microsoft.com/dotnet/api/system.collections.immutable.iimmutablelist-1">IImmutableList</a>&lt;<a class="xref" href="Ubiquity.CommandLineParsing.ICommandLineArgument.html">ICommandLineArgument</a>&gt;</dt>
    <dd><p>The list of parsed arguments in the order they appeared on the command line.</p>
</dd>
  </dl>







  <h4 class="section" id="Ubiquity_CommandLineParsing_ICommandLineParser_Parse_System_Collections_Generic_IEnumerable_System_String___remarks">Remarks</h4>
  <div class="markdown level1 remarks"><p>This will parse the command line into the various components in the order they appeared
on the command line. The ordering is important as some application may depend on specific
ordering of the command line. For example git command lines usually take the form:
`git (-o --option)? command (-o --option)*`
Where each command has a different set of options it allows. Thus the first item must always
be a positional value. (or not, as git itself may have some options too). Thus, the actual
ordering of the results matters as the options that precede or follow a positional value may
act as modifiers for the values.</p>
<p>Another, related, benefit of returning the arguments in the order supplied is to allow
for applications that desire space delimited values of options. For example the input text
`-optionWithValue optionvalue -optionwithoutvalue positional` will return four items in
the list. Only the application, which understands the semantics, can know that `optionvalue`
really is the value to associate with the preceding option `-optionWithValue`.</p>
</div>


  <dl class="typelist seealso">
    <dt>See Also</dt>
    <dd>
    <div><a class="xref" href="Ubiquity.CommandlineParsing.CommandlineArgAttribute.html#Ubiquity_CommandLineParsing_CommandlineArgAttribute_AllowSpaceDelimitedValue">AllowSpaceDelimitedValue</a></div>
    </dd>
  </dl>



</article>

        <div class="contribution d-print-none">
          <a href="https://github.com/UbiquityDotNET/CommandLineParsing/blob/master/src/Ubiquity.CommandlineParsing/ICommandLineParser.cs/#L43" class="edit-link">Edit this page</a>
        </div>


      </div>

      <div class="affix">
        <nav id="affix"></nav>
      </div>
    </main>


    <footer class="border-top text-secondary">
      <div class="container-xxl">
        <div class="flex-fill">
          Copyright (C) 2017-2025, Ubiquity.NET contributors
        </div>
      </div>
    </footer>
  </body>
</html>
